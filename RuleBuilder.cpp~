#include "RuleBuilder.h"
RuleBuilder::RuleBuilder(string ruleString)
{
   this->ruleString = ruleString;
}
TiXmlElement * RuleBuilder::RuleString2XMLElement()
{

   TiXmlElement *root = new TiXmlElement("");
   string express = del_blank(ruleString);
   ConstructOr(express,root,1);

   return root;
}
string RuleBuilder::RuleString2XMLString()
{
    TiXmlDocument * doc = new TiXmlDocument();
    TiXmlElement * root = RuleString2XMLElement();
    doc->LinkEndChild(root);
    return xml2string(doc);
}
void RuleBuilder::CreatePolicyFile(char *path)
{
    TiXmlDocument *doc = new TiXmlDocument();
    TiXmlElement * root = RuleString2XMLElement();
    doc->LinkEndChild(root);
    doc->SaveFile(path);


}
bool  RuleBuilder::CheckRule(string rule,string &error)
{
   boost::regex reg("((\\^|([^&\\|=\\)\\(]+=[^&\\|=\\)\\(]+))"
	"((\\|\\|)|(&&)))*(\\^|([^&\\|=\\)\\(]+=[^&\\|=\\)\\(]+))");
   string express = del_blank(rule);
   vector<string> vectorReplacement = ReplaceBracket(express);

   if(!boost::regex_match(vectorReplacement[0],reg))
   {
       error = rule;
       if(vectorReplacement[0].find_first_of("^",1) != vectorReplacement[0].npos)
       {
            error +="\n" + replace(vectorReplacement[0],"\\^","(...)");
       }
       return false;
   }

   for(int i = 1;i<vectorReplacement.size();i++)
   {
      if(!CheckRule(vectorReplacement[i],error))
      {
            return false;
      }
   }
    
   return true;
}

bool RuleBuilder::Check(string &error)
{
   return CheckRule(ruleString,error);
}
vector<string> RuleBuilder::ReplaceBracket(string express)
{
         string regString = "\\((?:(?>[^()]+)|(?0))*\\)"; 

         boost::smatch what; 
         boost::regex  reg(regString); 

         string::const_iterator start = express.begin(); 
         string::const_iterator end = express.end();
 
	 vector<string> vectorReplacement = vector<string>();

         vectorReplacement.push_back(boost::regex_replace(express,reg,"^"));


         while (boost::regex_search(start,end,what,reg)) 
         { 
              string msg(what[0].first+1, what[0].second-1); 
	      vectorReplacement.push_back(msg);  
              start = what[0].second;
         }

	return vectorReplacement;
} 

string RuleBuilder::RecoverBracket(string express,vector<string> vec,int &count)
{
    	string::size_type pos = 0;

    	while((pos=express.find_first_of("^",pos))
                    != string::npos)
   	{
        	express = express.replace(pos,1,"("+vec[count++]+")");
    	}
    	return express;
}
void RuleBuilder::ConstructOr(string express,TiXmlElement * parent,int index)
{
    vector<string> vectorReplacement = ReplaceBracket(express);

    vector<string> vectorOr = splite(vectorReplacement[0],"\\|\\|");

    int count = 1;

    if(vectorOr.size() > 1)
    {
        init_node(parent,1,index,"1");

        for(int i=0;i<vectorOr.size();i++)
        {
            TiXmlElement *child = new TiXmlElement("");
            parent->LinkEndChild(child);

            if(vectorOr[i] == "^")
            {
                ConstructOr(vectorReplacement[count++],child,i+1);
            }
            else if(vectorOr[i].find("^") != vectorOr[i].npos)
            {
                string undoExpress = RecoverBracket(vectorOr[i],vectorReplacement,count);
                ConstructAnd(undoExpress,child,i+1);
            }
            else
            {
                ConstructAnd(vectorOr[i],child,i+1);
            }
        }
    }
    else
    {
        string undoExpress = RecoverBracket(vectorOr[0],vectorReplacement,count);
        ConstructAnd(undoExpress,parent,index);  
    }
}

void RuleBuilder::ConstructAnd(string express,TiXmlElement *parent,int index)
{
    vector<string> vectorReplacement = ReplaceBracket(express);
    vector<string> vectorAnd = splite(vectorReplacement[0],"&&");

    int count =1;

    if(vectorAnd.size() > 1)
    {
        init_node(parent,1,index,int2str(vectorAnd.size()));

        for(int i=0;i<vectorAnd.size();i++)
        {
            TiXmlElement * child = new TiXmlElement("");
            parent->LinkEndChild(child);
       
            if(vectorAnd[i] == "^")
            {
                ConstructOr(vectorReplacement[count++],child,i+1);
            }   
            else
            {
                vector<string> value = splite(vectorAnd[i],"=");
                init_node(child,0,i+1,value[1]);
            }
        }
    }
    else
    {   
        vector<string> value = splite(vectorAnd[0],"=");
        init_node(parent,0,index,value[1]); 
    }

}

